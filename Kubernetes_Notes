Kubernetes(K8S)

Kubernetes = container management system that ensures your apps run reliably, scale automatically, and recover from failures.

- Kubernetes is an open-source container orchestration platform
- It was originally developed by Google, now maintained by the Cloud Native Computing Foundation (CNCF).
- It automates deployment, scaling, and management of containerized applications.

Without Kubernetes:

- You’d have to manually start/stop containers.
- Handle crashes, scaling, and networking yourself.

With Kubernetes:

- Self-healing: Restarts failed containers automatically.
- Load balancing: Distributes traffic between pods.
- Scaling: Adds/removes containers when needed.
- Rolling updates: Deploy new app versions with zero downtime.
- Resource management: Efficiently uses CPU/RAM.



Cluster → A group of machines (nodes).
Control Plane (Master Node) → manages the cluster.
Worker Nodes → run applications.
Pod → Smallest deployable unit in Kubernetes (1 or more containers).
Deployment → Manages pods, scaling, and rolling updates.
Service → Exposes pods inside or outside the cluster (stable networking).
ConfigMap & Secret → Store app configuration and sensitive data.
Namespace → Virtual cluster inside a cluster, helps organize resources.



High-Level Architecture

API Server → Entry point (kubectl talks to this).
Scheduler → Decides which node runs a pod.
Controller Manager → Ensures cluster desired state = actual state.
etcd → Key-value store (brain of the cluster).
Kubelet → Runs on each worker node, manages pods.
Kube Proxy → Handles network routing.



POD:
- A Pod is the smallest and simplest deployable unit in Kubernetes.
- Think of a Pod as a wrapper around containers that makes them work as a single unit in Kubernetes.

Smallest unit – Kubernetes doesn’t run containers directly; it runs Pods.
One or multiple containers – usually one container per pod, but sometimes multiple (sidecar pattern).
Shared networking – all containers in a Pod share the same IP.
Shared storage – they can mount the same persistent volumes.
Ephemeral – Pods are temporary. If a Pod dies, Kubernetes replaces it with a new one (not the same Pod).

eg: #vim firstpod.yml

apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: nginx-container
    image: nginx:latest
    ports:
    - containerPort: 80

#kubectl apply -f firstpod.yaml

#kubectl get pods  ======> 

#kubectl get pods -o wide  =====> Detail description of POD

#kubectl describe pod my-pod

#kubectl delete pod my-pod     OR kubectl delete -f firstpod.yml   =======> Delete a pod




============================================================================================================================================================
Namespace:

 A namespace is a logical isolation or grouping mechanism within a Kubernetes cluster.
 It allows you to divide cluster resources among multiple users, teams, or projects.
 Think of it as a virtual cluster inside a physical cluster.

- A Namespace is a way to logically separate and organize resources in a Kubernetes cluster.

- Resource isolation 

Resolved :
   - Avoide Name Clash
   - controll communication --Network policies like firewall
   - Apply Quota
   - Limit Range 

Default Namespaces in Kubernetes

****** When you create a new cluster, Kubernetes comes with four default namespaces:

Namespace	Purpose
default ----	Used for objects with no namespace specified
kube-system	---- Contains system components (e.g., kube-dns, kube-proxy, scheduler)
kube-public	---- Publicly readable data (rarely used)
kube-node-lease	------For node heartbeats (used by kubelet for performance)


Method 1: Create Namespace with Command
#kubectl create namespace dev =====> Craete a namespace

#kubectl get namespaces =====> List of Namespaces
Output:
NAME              STATUS   AGE
default           Active   2d21h
kube-node-lease   Active   2d21h
kube-public       Active   2d21h
kube-system       Active   2d21h


#kubectl get ns 
Output:
NAME              STATUS   AGE
default           Active   2d21h
kube-node-lease   Active   2d21h
kube-public       Active   2d21h
kube-system       Active   2d21h

#kubectl create namespace dev ========> Create a namespace

#kubectl delete namespace dev =========> Delete Namespace

#kubectl get pods -n dev ===============> Get resources inside a namespace

#kubectl config set-context --current --namespace=dev ====> Set a default namespace for kubectl

======================================================================================================================================================================

Method 2:Create Namespace with YAML
#vim namespace.yml

apiVersion: v1
kind: Namespace
metadata:
  name: dev

#kubectl apply -f namespace.yml


Method 3: Use Namespace for Resources

vim namespace.yaml

apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  namespace: dev    # Name of namespace dev
spec:
  containers:
  - name: nginx
    image: nginx


#kubectl apply -f namespace.yaml



Or using command line:
#kubectl run nginx-pod --image=nginx -n dev




======================================================================================================================================================================





#kubectl cluster-info  OR kubectl cluster-info dump  =========> Shows information about the cluster (API server, DNS, etc.).

#kubectl get nodes =============> Lists all nodes in the cluster and their status.

#kubectl get pods   ======>  Lists pods in the current namespace.

#kubectl get pods -o wide  ====> Shows pods with more details (node, IP, etc.).

#kubectl describe pod <pod-name>  ====> Shows detailed info about a specific pod.

#kubectl describe node <node-name>  ====> Shows detailed info about a specific node.

#kubectl logs <pod-name>
